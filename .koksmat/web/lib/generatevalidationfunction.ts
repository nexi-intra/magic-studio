function uppercaseFirstLetter(str: string) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function className(str: string) {
  const s = str.split("_");
  return s.map(uppercaseFirstLetter).join("");
}
export function generateDatabaseCallSourceCode(
  databaseName: string,
  procedureName: string,
  jsonSchema: any,
  zodSchema: string
): { source: string; import: string; call: string } {
  // Get the properties of the schema
  const properties = Object.keys(jsonSchema.properties).filter(
    (key) => key !== "tenant" && key !== "searchindex"
  );

  // Create the TypeScript type definition
  const typeDefinition = properties
    .map((key) => `${key}: ${jsonSchema.properties[key].type}`)
    .join("; ");

  // Create the TypeScript function parameter list
  const parameterList = properties
    .map((key) => `${key}: ${jsonSchema.properties[key].type}`)
    .join(",\n ");

  // Create the class source code
  const classSource = `
/**
 * This function is generated by Koksmat Studio v0.1
 * Feel free to modify it as needed
 * 
 */

import { z, ZodObject } from "zod";
import { execute } from "@/actions/client";

// The schema for the ${className(procedureName)} procedure
const _schema = ${zodSchema}

//  TypeScript type based on the schema
export type ${className(procedureName)}Props = z.infer<typeof _schema>;

// Exclude 'tenant' and 'searchindex' from the type
export type InputType = Omit<${className(procedureName)}Props, "tenant" | "searchindex">;

/**
// Example usage of the  function ${className(procedureName)}
try {
  const  result =  ${className(procedureName)}(${"\n    authtoken, // ensure this is a valid token\n   "} ${properties.map((key) => `${key}, //replace ${key} with your own variable`).join("\n    ")});
  
  
} catch (error) {
  console.error( error.message);
}
  */

export default async function ${className(procedureName)} (${"\n authtoken : string,\n "}${parameterList}${",\n id? : number,\n"}) {
  // constructs an object from the input parameters
  const input = { ${properties.join(", ")} };  
  
  // The tenant name and search index are applied upstream, so they are omitted from the schema
  const __schema = _schema.omit({ tenant: true, searchindex: true });

  // Input data is validated against the schema, and might be transform during that process
  const item = __schema.safeParse(input);  

  if (!item.success) {
    throw new Error(item.error.errors.map(err => err.message).join(', '));
  }

  const dbrecord = {...item.data,tenant:"",searchindex:"",id:id}
  const result = await execute(
    authtoken, // <-- this is the authentication token containing the user's credentials - the upn will be used as "actor" name
    "${databaseName}", // <-- this is a reference to a record in the connections table in the mix database
    "magic-mix.app", // <-- this is the service name processing the request
    "${procedureName}", // <-- this is the name of the procedure in the database pointed to by the connection
    dbrecord // <-- this is the data to be sent to the procedure
  );
  if (result.hasError) {
    throw new Error(result.errorMessage);
  }
  return result.data;

}

  




  `;

  return {
    source: classSource,
    import: `import { ${className(procedureName)} } from "/@/actions/database/${databaseName}/${procedureName}";`,
    call: `const result = await ${className(procedureName)}(authtoken, ${properties.join(", ")},id)`,
  };
}
