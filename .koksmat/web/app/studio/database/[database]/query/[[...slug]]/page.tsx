"use client";
import { SqlQueryEditor } from "@/components/sql-query-editor";
import { MagicboxContext } from "@/app/koksmat/magicbox-context";

import React, { useContext, useEffect, useState } from "react";
import CreateSqlquery from "@/actions/database/mix/create_sqlquery";
import { APPNAME } from "@/app/global";
import { useRouter } from "next/navigation";
import { QueryEditorToolbar } from "@/components/query-editor-toolbar";
import { useDatabaseMixSqlqueryItemRead } from "@/components/hooks/useDatabaseMixSqlqueryItemRead";
import { useDatabaseMixSqlqueryItemUpdate } from "./useDatabaseMixSqlqueryItemUpdate";





/*
You might need one of the following imports - uncomment the one you need
*/
import { execute } from "@/actions/client";
import { useToast } from "@/components/ui/use-toast";
import { de } from "date-fns/locale";
import { describe } from "nats/lib/nats-base-client/parser";
import EditableText from "@/components/editable-text";
// import React, { useEffect, useState } from "react";


function useDatabaseMixSqlqueryItemCreate(database: string) {
  /* ---------------------- Create Record ---------------------- 
* This code is generated by Koksmat Studio. You can modify it as you like.
* The code is generated based on the database and table you have selected.
* No warranty is given for the code.
* 
* Suggest that you use the refactor function and move the code to a separate file,
* then move that file to a folder where you keep your custom hooks.

* ----------------------------------------------------------
*/

  interface MixSqlqueryItem {
    id: number;
    created_at: string;
    created_by: string;
    updated_at: string;
    updated_by: string;
    deleted_at: null;
    tenant: string;
    searchindex: string;
    name: string;
    description: string;
    sql: string;
    connection_id: number;
    schema: Schema;
    koksmat_masterdataref: null;
    koksmat_bucket: null;
    koksmat_masterdata_id: null;
    koksmat_masterdata_etag: null;
    koksmat_state: null;
    koksmat_compliancetag: null;
  }
  interface Schema {
    schema: string;
  }
  type updateMixSqlqueryItem = Omit<MixSqlqueryItem, "id" | "created_at" | "created_by" | "updated_at" | "updated_by" | "deleted_at" | "koksmat_masterdataref" | "koksmat_bucket" | "koksmat_masterdata_id" | "koksmat_masterdata_etag" | "koksmat_state" | "koksmat_compliancetag">;
  const magicbox = useContext(MagicboxContext);
  const [error, seterror] = useState("");
  const [loading, setloading] = useState(false);
  const [result, setresult] = useState<any>();
  const toaster = useToast()
  const createItem = async (record: updateMixSqlqueryItem) => {
    setloading(true);
    seterror("");
    const result = await execute(
      magicbox.authtoken, // <-- this is the authentication token containing the user's credentials - the upn will be used as "actor" name
      database, // <-- this is a reference to a record in the connections table in the mix database
      "magic-mix.app", // <-- this is the service name processing the request
      "create_sqlquery", // <-- this is the name of the procedure in the database pointed to by the connection
      record // <-- this is the data to be sent to the procedure
    );
    if (result.hasError) {
      seterror(result.errorMessage ?? "Unknown error");
      toaster.toast({ title: "Error", description: result.errorMessage ?? "Unknown error" })
    } else {


      if (result.data) {
        const databaseResult: any = result.data;
        toaster.toast({ title: "New record created", description: "Taking you there" })
        setTimeout(() => {
          window.location.href = `/studio/database/${APPNAME}/query/${databaseResult.id}`
        }, 1000)
      }

    }

    setloading(false);
    if (result.hasError) {
      seterror(result.errorMessage ?? "Unknown error");
    }
    setresult(result);


  }
  return { createItem, error, loading, result };
}


function summarizeSQL(sql: string): string {
  // Extract the main SQL operation (SELECT, INSERT, UPDATE, DELETE)
  const match = sql.match(/(SELECT|INSERT|UPDATE|DELETE)\s/i);
  let operation = match ? match[1] : 'SQL';

  // Try to capture the main table name from FROM, INTO, or UPDATE clauses
  let tableMatch = sql.match(/(?:FROM|INTO|UPDATE)\s+(\w+)/i);
  let tableName = tableMatch ? tableMatch[1] : 'Unknown Table';

  // Combine the operation and table name
  let summary = `${operation} on ${tableName}`;

  // Add context like WHERE clause or LIMIT if they exist
  const whereMatch = sql.match(/WHERE\s+(.+?)(\s+|$)/i);
  if (whereMatch) {
    summary += ` with condition (${whereMatch[1].substring(0, 20)}...)`;
  }

  // Add limit if available
  const limitMatch = sql.match(/LIMIT\s+(\d+)/i);
  if (limitMatch) {
    summary += ` with limit ${limitMatch[1]}`;
  }

  // Truncate to 50 characters
  if (summary.length > 50) {
    summary = summary.substring(0, 47) + '...';
  }

  return summary;
}



export default function Page(props: { params: { database: string, slug: string[] } }) {
  const router = useRouter();
  const { database, slug } = props.params;
  const subpath = slug ? slug.join("/") : ""
  const [name, setname] = useState("New Query");

  const [showSheet, setshowSheet] = useState(true);
  const magicbox = useContext(MagicboxContext);
  const [error, seterror] = useState("");
  const toolbar = <QueryEditorToolbar database={database} handleSave={async () => {
    if (!databaseRecord) {
      const r = await createItem({
        name,
        sql: sql.replaceAll("'", "''"),
        connection_id: 1,
        description: "",
        searchindex: "",
        tenant: "",
        schema: { schema: "mix" }
      })

      return
    }

    seterror("");
    // debugger
    databaseRecord.sql = sql.replaceAll("'", "''");
    databaseRecord.name = name;
    sqlQueryUpdater.update({ ...databaseRecord })

  }} />;
  const { databaseRecord, isLoading, error: databaseerror } = useDatabaseMixSqlqueryItemRead(database, subpath);  // replace props.id with the id of the record you want to load
  const sqlQueryUpdater = useDatabaseMixSqlqueryItemUpdate(database);
  const { createItem } = useDatabaseMixSqlqueryItemCreate(database);
  const [nameManuallySet, setnameManuallySet] = useState(false)
  const [sql, setsql] = useState(`
  /**
   * Write your query here
   * and click on the Run button
   */        
          
  select 1 as result`)
  useEffect(() => {
    seterror(databaseerror)
    if (databaseRecord) {
      setsql(databaseRecord.sql.replaceAll("''", "'"))
      setname(databaseRecord.name)
    }

  }, [databaseRecord, databaseerror])

  useEffect(() => {
    if (!subpath) {
      return;
    }


  }, [subpath])





  return (
    <div>

      <EditableText className="text-2xl" initialText={name} onSave={async (text: string) => {
        setnameManuallySet(true)
        setname(text)
        return true

      }} />
      <SqlQueryEditor
        toolbar={toolbar}
        database={database}
        name={name}
        onChange={async (newSQL: string) => {

          if (!databaseRecord && !nameManuallySet) {
            setname(summarizeSQL(newSQL))
          }
          setsql(newSQL)
        }}
        sql={sql}
      />

    </div>

  );
}
